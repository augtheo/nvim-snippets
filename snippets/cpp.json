{
  "Minimal Base template for competitive programming": {
    "prefix": "minbase",
    "body": [
      "#include <bits/stdc++.h>",
      "#include <ext/pb_ds/assoc_container.hpp>",
      "#include <ext/pb_ds/tree_policy.hpp>",
      "",
      "#ifdef LOCAL",
      "#include \"augtheo/debug.h\"",
      "#else",
      "#define debug(...)",
      "#endif",
      "",
      "using namespace std;",
      "using namespace __gnu_pbds;",
      "",
      "using ll = long long;",
      "using ld = long double;",
      "template <typename T>",
      "using orderedSet =",
      "    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;",
      "template <typename T>",
      "using orderedMultiset = tree<T, null_type, less_equal<T>, rb_tree_tag,",
      "                             tree_order_statistics_node_update>;",
      "",
      "inline void fastio() {",
      "  ios_base::sync_with_stdio(false);",
      "  cin.tie(nullptr);",
      "  cout.tie(nullptr);",
      "  cout.precision(10);",
      "  cout << fixed;",
      "}",
      "",
      "int main() { ",
      "  fastio();",
      "  ${1}",
      " }",
      ""
    ],
    "description": "Minimal Base template for competitive programming"
  },
  "Disjoint Sets": {
    "prefix": "dsu",
    "body": [
      "struct DisjointSets {",
      "  int n, cnt;",
      "  vector<int> p,r;",
      "  DisjointSets(int n) : n(n), cnt(n) , p(n) , r(n) {",
      "    iota(p.begin(), p.end() , 0);",
      "  }",
      "  int find(int i) {",
      "    return (i == p[i] ? i : p[i] = find(p[i]));",
      "  }",
      "  void join(int i , int j) {",
      "    if((i = find(i)) == (j = find(j))) return;",
      "    if(r[i] < r[j]) swap(i , j);",
      "    p[j] = i;",
      "    cnt--;",
      "    if(r[i] == r[j]) r[i]++;",
      "  }",
      "};"
    ],
    "description": "Disjoint Sets"
  },
  "Algorithm to exponentiate efficiently": {
    "prefix": "binpow",
    "body": [
      "ll binpow(ll x, ll n,ll mod = ${1:MOD} )",
      "{",
      "  ll ans =1;",
      "  x = x%mod;",
      "  while(n>=1)",
      "  {",
      "    if(n&1)",
      "      ans=(ans*x)%mod;",
      "    x=(x*x)%mod;",
      "    n>>=1;",
      "  }",
      "  return ans;",
      "}",
      "",
      ""
    ],
    "description": "Algorithm to exponentiate efficiently"
  },
  "Graph Starter": {
    "prefix": "graph",
    "body": [
      "template <typename T> class Graph {",
      "public:",
      "  Graph(int n) : n(n) { adj.resize(n); }",
      "  void add_edge(int u, int v, T w = 1) { adj[u].push_back(make_pair(v, w)); }",
      "  void dfs(int u, int p) {",
      "    for (auto &[v, w] : adj[u]) {",
      "      if (v != p) {",
      "        dfs(v, u);",
      "      }",
      "    }",
      "  }",
      "  void solve() { dfs(0, -1); }",
      "",
      "private:",
      "  int n;",
      "  vector<vector<pair<int, T>>> adj;",
      "};",
      ""
    ],
    "description": "Graph Starter"
  },
  "SieveEratosthenes": {
    "prefix": "sieve-eratosthenes",
    "body": [
      "template<typename T>",
      "class SieveEratosthenes",
      "{",
      "  public:",
      "    vector<T> primes;",
      "    vector<bool> is_prime;",
      "    SieveEratosthenes(int MAX = 1000000)",
      "    {",
      "      is_prime.resize(MAX + 1, true);",
      "      is_prime[0] = is_prime[1] = false;",
      "      for(ll i = 2; i*i<=MAX; i++)",
      "        if(is_prime[i])",
      "          for(ll j = i*i; j<=MAX; j+=i)",
      "            is_prime[j] = false;",
      "      for(ll i =2; i<=MAX; i++)",
      "        if(is_prime[i])",
      "          primes.push_back(i);",
      "    }",
      "};",
      ""
    ],
    "description": "SieveEratosthenes"
  },
  "SieveEuler": {
    "prefix": "sieve-euler",
    "body": [
      "",
      "template<typename T>",
      "struct SieveEuler",
      "{",
      "    vector<T> primes , lp , cnt;",
      "    void SieveEuler(int MAX = 1000000)",
      "    {",
      "        lp.resize(MAX + 1, 0) , cnt.resize(MAX + 1, 0);",
      "        for(ll i = 2; i<= MAX; i++)",
      "        {",
      "            if(lp[i] == 0)",
      "                {",
      "                    lp[i] = i , cnt[i] = 1;",
      "                    primes.push_back(i);",
      "                }",
      "            for(int j = 0; j< primes.size() && i*primes[j] <= MAX && primes[j]<= lp[i]; ++j)",
      "                {",
      "                    if(primes[j] == lp[i])",
      "                        lp[i*primes[j]]  = primes[j] ,cnt[i*primes[j]] = cnt[i] + 1;",
      "                    else ",
      "                        lp[i*primes[j]]  = primes[j] ,cnt[i*primes[j]] = 1;",
      "                }",
      "        }",
      "    }",
      "};"
    ],
    "description": "Build the prime sieve in O(n). Used also for computing multiplicative functions."
  },
  "LCA": {
    "prefix": "lca",
    "body": [
      "struct LCA {",
      "    vector<int> height, euler, first, segtree , sz , parent;",
      "    vector<bool> visited;",
      "    int n;",
      " ",
      "    LCA(vector<vector<int>> &adj, int root = 0) {",
      "        n = adj.size();",
      "        height.resize(n);",
      "        first.resize(n);",
      "        sz.resize(n);",
      "        parent.resize(n, -1);",
      "        euler.reserve(n * 2);",
      "        visited.assign(n, false);",
      "        dfs(adj, root);",
      "        int m = euler.size();",
      "        segtree.resize(m * 4);",
      "        build(1, 0, m - 1);",
      "    }",
      " ",
      "    void dfs(vector<vector<int>> &adj, int node, int h = 0) {",
      "        visited[node] = true;",
      "        height[node] = h;",
      "        sz[node] = 1;",
      "        first[node] = euler.size();",
      "        euler.push_back(node);",
      "        for (auto to : adj[node]) ",
      "        {",
      "            if (!visited[to]) ",
      "            {",
      "                parent[to] = node;",
      "                dfs(adj, to, h + 1);",
      "                sz[node] += sz[to];",
      "                euler.push_back(node);",
      "            }",
      "        }",
      "    }",
      " ",
      "    void build(int node, int b, int e) {",
      "        if (b == e) {",
      "            segtree[node] = euler[b];",
      "        } else {",
      "            int mid = (b + e) / 2;",
      "            build(node << 1, b, mid);",
      "            build(node << 1 | 1, mid + 1, e);",
      "            int l = segtree[node << 1], r = segtree[node << 1 | 1];",
      "            segtree[node] = (height[l] < height[r]) ? l : r;",
      "        }",
      "    }",
      " ",
      "    int query(int node, int b, int e, int L, int R) {",
      "        if (b > R || e < L)",
      "            return -1;",
      "        if (b >= L && e <= R)",
      "            return segtree[node];",
      "        int mid = (b + e) >> 1;",
      " ",
      "        int left = query(node << 1, b, mid, L, R);",
      "        int right = query(node << 1 | 1, mid + 1, e, L, R);",
      "        if (left == -1) return right;",
      "        if (right == -1) return left;",
      "        return height[left] < height[right] ? left : right;",
      "    }",
      " ",
      "    int lca(int u, int v) {",
      "        int left = first[u], right = first[v];",
      "        if (left > right)",
      "            swap(left, right);",
      "        return query(1, 0, euler.size() - 1, left, right);",
      "    }"
    ]
  },
  "ZFunction": {
    "prefix": "zfunc",
    "body": [
      "vector<int> z_function(string& s)",
      "{",
      "    int n = s.length();",
      "    vector<int> z(n, 0);",
      "    for(int i = 1 , l = 0  , r = 0; i < n ; i++)",
      "    {",
      "        if(i<= r)",
      "            z[i] = min(z[i - l ] , r - i + 1);",
      "        while(i + z[i] < n && s[i + z[i]] == s[z[i]])",
      "            ++z[i];",
      "        if(i + z[i] - 1 > r)",
      "            l = i , r = i + z[i] - 1;",
      "    }",
      "    return z;",
      "}",
      ""
    ],
    "description": "ZFunction"
  },
  "SegmentTree": {
    "prefix": "seg",
    "body": [
      "template<typename T>",
      "class SegmentTree",
      "{",
      "  public:",
      "  vector<T> t;",
      "  int n, H;",
      "  void init(int n)",
      "  {",
      "    this->n = n;",
      "    t.resize(2*n);",
      "    this->H = sizeof(int)*8 - __builtin_clz(n);",
      "  }",
      "  void build()",
      "  {",
      "    for(int i = n-1; i>0;i--)",
      "      t[i] = t[i<<1] + t[(i<<1)|1];",
      "  }",
      "  void update(int pos, T val)",
      "  {",
      "    for(t[pos+=n]+= val ; pos>1;pos>>=1)",
      "      t[pos>>1] = t[pos] + t[pos^1];",
      "  }",
      "  T  query(int l, int r)",
      "  {",
      "    T res =0;",
      "    for(l+=n,r+=n;l<r;l>>=1,r>>=1)",
      "    {",
      "      if(l&1)     res+=t[l++];",
      "      if(r&1)     res+=t[--r];",
      "    }",
      "    return res;",
      "  }",
      "};",
      ""
    ],
    "description": "SegmentTree"
  },
  "Factorial": {
    "prefix": "fact",
    "body": [
      "vector<ll> fact, ifact;",
      "void buildFact(int N , ll mod = MOD)",
      "{",
      "    fact.resize(N + 1 ) , ifact.resize(N + 1) ; fact[0] = fact[1] = 1;",
      "    for(int i = 2; i<= N; i++)",
      "        fact[i] = (i*fact[i-1])%mod;",
      "    ifact[N] = modInverse(fact[N] , mod);",
      "    for(int i = N - 1; i>= 0 ; i--)",
      "        ifact[i] = ( (i + 1)*ifact[i + 1])%mod;",
      "}",
      ""
    ],
    "description": "Factorial"
  }
}
